use crate::ppu::renderer::{PixelBuffer, HEIGHT, WIDTH};
use eframe::egui;
use std::sync::mpsc::Receiver;

/// The screen to show pixels generated by the PPU.
pub struct Screen {
    texture: Option<egui::TextureHandle>,
    receiver: Receiver<Box<PixelBuffer>>,
}

impl Screen {
    pub fn new(receiver: Receiver<Box<PixelBuffer>>) -> Self {
        Self {
            texture: None,
            receiver,
        }
    }

    pub fn widget(&mut self) -> impl egui::Widget + '_ {
        move |ui: &mut egui::Ui| {
            // TODO: Retain the original aspect ratio
            let width = ui.available_width();
            let height = ui.available_height();

            ui.horizontal(|ui| {
                if let Some(texture) = &self.texture {
                    ui.image(texture, [width, height]);
                }
            })
            .response
        }
    }

    /// Update the internal texture with a pixel buffer, if the PPU has generated one.
    pub fn update_buffer(&mut self, ctx: &egui::Context) {
        if let Some(buf) = self.receiver.try_iter().last() {
            self.texture = Some(ctx.load_texture(
                "screen-with-pixels",
                egui::ColorImage::from_rgb([WIDTH, HEIGHT], &*buf),
                egui::TextureOptions::NEAREST,
            ));
        }
    }
}
